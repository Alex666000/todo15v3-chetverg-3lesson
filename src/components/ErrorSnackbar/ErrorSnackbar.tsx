import * as React from "react";
import Snackbar from "@mui/material/Snackbar";
import MuiAlert, {AlertProps} from "@mui/material/Alert";
import {useDispatch, useSelector} from "react-redux";
import {AppRootStateType} from "../../app/store";
import {setAppErrorAC} from "../../app/app-reducer";


const Alert = React.forwardRef<HTMLDivElement, AlertProps>(function Alert(
    props, ref) {
    return <MuiAlert elevation={6} ref={ref} variant="filled" {...props} />
})

// переименовали снекбар на ErrorSnackbars
// тут используется лок стейт нам надо перделать на редакс - сначала меняются данные потом видим отрисовку
export default function ErrorSnackbar() {
    // const [open, setOpen] = React.useState(false);
    const dispatch = useDispatch()
    const error = useSelector<AppRootStateType, string | null>(state => state.app.error)

    const handleClose = (event?: React.SyntheticEvent | Event, reason?: string) => {
        // 1 причина закрытия - кликнули мимо reason === clickaway...или нажали на крестик
        // 2 проходит время и причина менятся на reason === timeout и мы уже не попадем в обрыв функции
        // 3 причина когда кликаем на крестик reason === undefined
        // console.log(reason)
        // debugger

        if (reason === "clickaway") {
            // обрав функции - выпрыгнем из нее и ничего не произойдет
            return
        }
        // через 3 сек. ошибка исчезнет
        // - тоже исчезнет при нажатии на крестик
        dispatch(setAppErrorAC(null))
        // после нажатия на крестик устанавливаем false и снекбар скрывается
        // setOpen(false)
    }
    // при рендере - показывать или нет Snackbar теперь будем - не на основе локального стейта
    // а глобального state


// есть ошибка = открыто будет окно...
    const isOpen = error !== null
    // 2 способ
    // open={!!error}

    return (
        /* тут показываем ошибку в Snackbar */
        <Snackbar open={isOpen} autoHideDuration={3000} onClose={handleClose}>
            <Alert onClose={handleClose} severity="error" sx={{width: "100%"}}>
                {error}
            </Alert>
        </Snackbar>
    )
    // при нажатии на крестик не закрывается - как закрыть? Надо чтобы в глобальном стейте
    // error: 'Some error' - превратился в null
}
// Дебажим Материал UI и смотрим как работатет - ставим несколько брекпоинтов
// Snackbar - тот алерт который всплывашкой выскакивает
// как правило всегда стейт контролируемый и видим что Snackbar контролируемый на вход передается open (видимый)
// autoHideDuration через 3 сек вызывает колбек на onClose - это handleClose
// если изначально не видим ошибку то меняем руками open на true и видм ее уже...
// удалим кнопку и handleClick так как мы будем показывать ошибку не по клику на нее
// classes удалим

// ОШИБКУ БУДЕМ ХРАНИТЬ В СТОРЕ РЕДАКСА - в Арр всего приложения
// ТАК КАК ОНА ГЛОБАЛЬНАЯ - если она придет сюда мы ее увидим и отобразим

/* ########################    Алгоритм:    ###########################################
- из Материала компоненту ошибки берем и переименовываем и подключаем в Арр
- сначала меняем руками true на false, потом делаем редюсер всего Арр, подключаем его
- потом диспатчим и меняем без сервера от UI к BLL
- тесты пишем
- потом делаем появление ошибки в правильный момент: Когда может упасть ошибка?
когда например отправим сильно длинный title - а сервак в "texarea" для таски (> 100 символов).
- в идеале проверки на ошибки надо делать на фронте и на бэке - в идеале и там и там - они друг другу не доверяют см. addTaskTC

Валидация ошибки должна быть на сервере(бэкенд валидацию должен делать всегда!). Надо обработать ошибку
- которую сервер возвращает.Смотрим ответ с сервера если ввели очень длинное название и видим
что ошибка сетевого уровня а не серверная:
["The field Title must be a string or array type with a maximum length of '100'. (Title)"] - нам должен
был вернуться объект его нет и ошибки на UI нет - надо ее показать
- Идем туда где обрабатывается создание таски ищем санку addTaskTC - так как операция на сервер...

-- Далее делаем крутилку достанем в Арр статус и покажем  <LinearProgress /> если status === "loading" -
см Арр.tsx

перед тем как таски получать скажем см. fetchTasksTC: dispatch(setStatusAC("loading")) и после окончания запроса крутилку убери
dispatch(setStatusAC("succeeded")). Смотрим на UI и видим крутилка убралась

- Чтобы не нажать на кнопку удаления таски много-много раз (имитировать можем поставить slow 3G... - мы все удаляем а на сервере все уже удалено и сервер кидает ошибку)
идет обработка конкретного тудулиста с конретным тудулистом что-то происходит
получается UX надо показать это - в сущность TodolistDomainType добавим status тудулиста - чтобы он со статусом Арр не
конфликтовал назовем его entityStatus (isLoading,isDisabled теперь никогда не пишем больше!!!))- статус сущности конкретной  перезаюзаем тип status_a - RequestStatusType
теперь поймем что с сущностью тудулистом что-то происходит - теперь сможем обрабатывать жизнь самого тудулиста
- не забываем в редюсере где добавляем туду добвить и статус
return action.todolists.map(tl => ({...tl, filter: 'all', entityStatus: 'idle'}))

--- как уметь читать свойства Компонент из Материал?
Жмем Ctrl + клик и попадаем внутрь open там видим документацию Материала…
читаем что означает "в зелёном тексте"

посмотреть что эта компонента умеет какие у нее свойство — в каждой К Материал у нее есть АПИ — интерфейс взаимодействия с чем то -такое есть в каждой Компоненте
можно законсолить или дебагером посмотреть например handleClose reason

// все id генерирует сервер мы использовали uuid до работы с серваком

АЛГОРИТМ:
 - написали initialState затипизировали новое данное например status
 - сделали руками зависимость UI от стейт посмотрели что страница стала статично - это свойсво
 - пишем АС,кейс, санку - санку диспатчим
 # Чтобы изменить UI сперва нужно изменить state. Чтобы изменить state нужно создать action creator, и написать case для изменения state. Думаем какие свойства нужны для АС при его создании

 */






